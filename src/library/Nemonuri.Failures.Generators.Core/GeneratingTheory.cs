using CommunityToolkit.Diagnostics;

namespace Nemonuri.Failures.Generators;

public static partial class GeneratingTheory
{
    private static string JoinStrings
    (
        this IEnumerable<string> strings,
        string? separator = null
    ) =>
    string.Join(separator ?? Environment.NewLine, strings);

    private static string ToUnionCaseAttributeExpression(this FailSlot failSlot)
    {
        Guard.IsNotNullOrWhiteSpace(failSlot.Name);

        if (failSlot.Type is { } typeExpression)
        {
            return $"[UnionCase(nameof(FailCode.{failSlot.Name}), typeof({typeExpression}))]";
        }
        else
        {
            return $"[UnionCase(nameof(FailCode.{failSlot.Name}))]";
        }
    }

    private static string ToEnumFieldExpression(this FailSlot failSlot, int index)
    {
        Guard.IsNotNullOrWhiteSpace(failSlot.Name);

        return $"{failSlot.Name} = {index}";
    }

    public static string GenerateCode
    (
        IEnumerable<string>? usings,
        string @namespace,
        string? rootClass,
        string methodAlias,
        string valueType,
        IEnumerable<FailSlot>? failSlots
    )
    {
        string internalClass = methodAlias + "Result";
        bool enableRootClass = !string.IsNullOrWhiteSpace(rootClass);
        failSlots ??= [];

        return
$$"""
// <auto-generated />
#nullable enable // For CS8669

using Nemonuri.Failures;
using SumSharp;
{{usings?.Select(static str => $"using {str};").JoinStrings()}}

namespace {{@namespace}};

{{(enableRootClass ?
$$"""
public static partial class {{rootClass}}
{
""" : ""
)}}
    public partial class {{internalClass}} :
        IValueOrFailure<{{valueType}}, {{internalClass}}.FailInfo>
    {
        {{failSlots
            .Select(static fs => fs.ToUnionCaseAttributeExpression())
            .JoinStrings(Environment.NewLine + "        ")}}
        public partial class FailInfo
        {
            public FailCode FailCode => (FailCode)(Index + 1);
        }

        public enum FailCode
        {
            {{failSlots
                .Prepend(new FailSlot() { Name = "Unknown" })
                .Select(static (fs, i) => fs.ToEnumFieldExpression(i))
                .JoinStrings("," + Environment.NewLine + "            ")}}
        }

        private readonly ValueOrFailure<{{valueType}}, FailInfo> _internalSource;

        public {{internalClass}}(ValueOrFailure<{{valueType}}, FailInfo> internalSource)
        {
            _internalSource = internalSource;
            System.Diagnostics.Debug.WriteLine("{{internalClass}} constructed. " + ToString());
        }

        public static {{internalClass}} CreateAsValue({{valueType}} value) =>
            new(value);
        
        public static {{internalClass}} CreateAsFailure(FailInfo failInfo, string message = "") =>
            new(FailureTheory.Create(failInfo, message));
        
{{failSlots
    .Select(fs => fs.ToCreateMethodExpression(internalClass, "        "))
    .JoinStrings()}}

        public bool IsValue => _internalSource.IsValue;

        public bool IsFailure => _internalSource.IsFailure;

        public {{valueType}} GetValue() => _internalSource.GetValue();

        public Failure<FailInfo> GetFailure() => _internalSource.GetFailure();

        public override string ToString() =>
            "{{internalClass}} {" +
            (
                IsValue ? 
                    ("IsValue = true, Value = " + GetValue()) :
                    ("IsFailure = true, Value = " + GetFailure())
            ) + " }";
    }
{{(enableRootClass ? "}" : "")}}
""";
    }
}