// <auto-generated />
#nullable enable // For CS8669

using Nemonuri.Failures;
using SumSharp;


namespace Nemonuri.Study.CSharpAICommentor;

public static partial class CSharpSyntaxTreeTheory
{
    public partial class CreateCompilationUnitRootedCSharpSyntaxTreeInfoResult :
        IValueOrFailure<CompilationUnitRootedCSharpSyntaxTreeInfo, CreateCompilationUnitRootedCSharpSyntaxTreeInfoResult.FailInfo>
    {
        [UnionCase(nameof(FailCode.Canceled))]
        [UnionCase(nameof(FailCode.CreateCSharpSyntaxTreeFromFileFailed), typeof(CSharpSyntaxTreeTheory.CreateCSharpSyntaxTreeFromFileResult.FailInfo))]
        [UnionCase(nameof(FailCode.GetRootFailed))]
        [UnionCase(nameof(FailCode.RootIsNotCompilationUnitSyntax), typeof(System.Type))]
        public partial class FailInfo
        {
            public FailCode FailCode => (FailCode)(Index + 1);
        }

        public enum FailCode
        {
            Unknown = 0,
            Canceled = 1,
            CreateCSharpSyntaxTreeFromFileFailed = 2,
            GetRootFailed = 3,
            RootIsNotCompilationUnitSyntax = 4
        }

        private readonly ValueOrFailure<CompilationUnitRootedCSharpSyntaxTreeInfo, FailInfo> _internalSource;

        public CreateCompilationUnitRootedCSharpSyntaxTreeInfoResult(ValueOrFailure<CompilationUnitRootedCSharpSyntaxTreeInfo, FailInfo> internalSource)
        {
            _internalSource = internalSource;
            System.Diagnostics.Debug.WriteLine("CreateCompilationUnitRootedCSharpSyntaxTreeInfoResult constructed. " + ToString());
        }

        public static CreateCompilationUnitRootedCSharpSyntaxTreeInfoResult CreateAsValue(CompilationUnitRootedCSharpSyntaxTreeInfo value) =>
            new(value);
        
        public static CreateCompilationUnitRootedCSharpSyntaxTreeInfoResult CreateAsFailure(FailInfo failInfo, string message = "") =>
            new(FailureTheory.Create(failInfo, message));
        
        public static CreateCompilationUnitRootedCSharpSyntaxTreeInfoResult CreateAsCanceled
        (string message = "") =>
            new(FailureTheory.Create(FailInfo.Canceled, message));

        public static CreateCompilationUnitRootedCSharpSyntaxTreeInfoResult CreateAsCreateCSharpSyntaxTreeFromFileFailed
        (CSharpSyntaxTreeTheory.CreateCSharpSyntaxTreeFromFileResult.FailInfo value, string message = "") =>
            new(FailureTheory.Create(FailInfo.CreateCSharpSyntaxTreeFromFileFailed(value), message));

        public static CreateCompilationUnitRootedCSharpSyntaxTreeInfoResult CreateAsGetRootFailed
        (string message = "") =>
            new(FailureTheory.Create(FailInfo.GetRootFailed, message));

        public static CreateCompilationUnitRootedCSharpSyntaxTreeInfoResult CreateAsRootIsNotCompilationUnitSyntax
        (System.Type value, string message = "") =>
            new(FailureTheory.Create(FailInfo.RootIsNotCompilationUnitSyntax(value), message));


        public bool IsValue => _internalSource.IsValue;

        public bool IsFailure => _internalSource.IsFailure;

        public CompilationUnitRootedCSharpSyntaxTreeInfo GetValue() => _internalSource.GetValue();

        public Failure<FailInfo> GetFailure() => _internalSource.GetFailure();

        public override string ToString() =>
            "CreateCompilationUnitRootedCSharpSyntaxTreeInfoResult {" +
            (
                IsValue ? 
                    ("IsValue = true, Value = " + GetValue()) :
                    ("IsFailure = true, Value = " + GetFailure())
            ) + " }";
    }
}